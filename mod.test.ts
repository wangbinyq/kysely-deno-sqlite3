import { Database as SqliteDatabase } from "https://deno.land/x/sqlite3@0.9.1/mod.ts";
import {
  Kysely,
  sql,
  ColumnType,
  Generated,
  Insertable,
  Selectable,
  Updateable,
  Migrator,
} from "kysely";
import { FileMigrationProvider, SqliteDialect } from "./mod.ts";
import { assertEquals } from "https://deno.land/std@0.192.0/testing/asserts.ts";
import {
  describe,
  beforeAll,
  afterEach,
  afterAll,
  it,
  beforeEach,
} from "https://deno.land/std@0.192.0/testing/bdd.ts";
import { up } from "./migrations/init.ts";

export interface Database {
  person: PersonTable;
  pet: PetTable;
}

export interface PersonTable {
  // Columns that are generated by the database should be marked
  // using the `Generated` type. This way they are automatically
  // made optional in inserts and updates.
  id: Generated<number>;

  first_name: string;
  gender: "man" | "woman" | "other";

  // If the column is nullable in the database, make its type nullable.
  // Don't use optional properties. Optionality is always determined
  // automatically by Kysely.
  last_name: string | null;

  // You can specify a different type for each operation (select, insert and
  // update) using the `ColumnType<SelectType, InsertType, UpdateType>`
  // wrapper. Here we define a column `created_at` that is selected as
  // a `Date`, can optionally be provided as a `string` in inserts and
  // can never be updated:
  created_at: ColumnType<Date, string | undefined, never>;
}

// You should not use the table schema interfaces directly. Instead, you should
// use the `Selectable`, `Insertable` and `Updateable` wrappers. These wrappers
// make sure that the correct types are used in each operation.
export type Person = Selectable<PersonTable>;
export type NewPerson = Insertable<PersonTable>;
export type EditedPerson = Updateable<PersonTable>;

export interface PetTable {
  id: Generated<number>;
  name: string;
  owner_id: number;
  species: "dog" | "cat";
}

export type Pet = Selectable<PetTable>;
export type NewPet = Insertable<PetTable>;
export type EditedPet = Updateable<PetTable>;

export async function findPersonById(id: Person["id"]) {
  return await db
    .selectFrom("person")
    .where("id", "=", id)
    .selectAll()
    .executeTakeFirst();
}

export async function findPeople(criteria: Partial<Person>) {
  let query = db.selectFrom("person");

  if (criteria.id) {
    query = query.where("id", "=", criteria.id); // Kysely is immutable, you must re-assign!
  }

  if (criteria.first_name) {
    query = query.where("first_name", "=", criteria.first_name);
  }

  if (criteria.last_name !== undefined) {
    query = query.where(
      "last_name",
      criteria.last_name === null ? "is" : "=",
      criteria.last_name
    );
  }

  if (criteria.gender) {
    query = query.where("gender", "=", criteria.gender);
  }

  if (criteria.created_at) {
    query = query.where("created_at", "=", criteria.created_at);
  }

  return await query.selectAll().execute();
}

export async function updatePerson(id: Person["id"], updateWith: EditedPerson) {
  await db.updateTable("person").set(updateWith).where("id", "=", id).execute();
}

export async function createPerson(person: NewPerson) {
  return await db
    .insertInto("person")
    .values(person)
    .returningAll()
    .executeTakeFirstOrThrow();
}

export async function deletePerson(id: Person["id"]) {
  return await db
    .deleteFrom("person")
    .where("id", "=", id)
    .returningAll()
    .executeTakeFirst();
}

const db = new Kysely<Database>({
  dialect: new SqliteDialect({
    database: new SqliteDatabase(":memory:"),
  }),
});

describe("PersonRepository", () => {
  beforeAll(async () => {
    await up(db);
  });

  beforeEach(async () => {
    await db
      .insertInto("person")
      .values({
        id: 123,
        first_name: "Arnold",
        last_name: "Schwarzenegger",
        gender: "man",
      })
      .execute();
  });

  afterEach(async () => {
    await sql`delete from ${sql.table("person")}`.execute(db);
  });

  afterAll(async () => {
    await db.schema.dropTable("person").execute();
  });

  it("should find a person with a given id", async () => {
    const person = await findPersonById(123);
    assertEquals(person?.first_name, "Arnold");
  });

  it("should find all people named Arnold", async () => {
    const persons = await findPeople({});
    assertEquals(persons.length, 1);
    assertEquals(persons[0].id, 123);
  });

  it("should update gender of a person with a given id", async () => {
    await updatePerson(123, { gender: "woman" });
    const person = await findPersonById(123);
    assertEquals(person?.gender, "woman");
  });

  it("should create a person", async () => {
    await createPerson({
      first_name: "Jennifer",
      last_name: "Aniston",
      gender: "woman",
    });
  });

  it("should delete a person with a given id", async () => {
    await deletePerson(123);
  });
});

Deno.test("Migrator", async () => {
  const migrator = new Migrator({
    db,
    provider: new FileMigrationProvider(),
  });

  const migrations = await migrator.getMigrations();

  assertEquals(migrations.length, 1);

  await migrator.migrateToLatest();

  assertEquals(await findPeople({}), []);
});
